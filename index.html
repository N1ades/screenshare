<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Private Screen Sharing</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }
        button {
            padding: 12px 24px;
            background-color: #4285f4;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #3367d6;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        .status {
            text-align: center;
            margin: 20px 0;
            font-weight: bold;
        }
        #shareLink {
            display: block;
            width: 100%;
            padding: 10px;
            margin: 10px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        #videoContainer {
            margin-top: 20px;
            text-align: center;
        }
        #remoteVideo {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            background-color: #000;
        }
        .hidden {
            display: none;
        }
        .info-section {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Private Screen Sharing</h1>
        
        <div id="sharerSection">
            <div class="buttons">
                <button id="shareButton">Share Screen</button>
                <button id="stopButton" disabled>Stop Sharing</button>
            </div>
            
            <div id="connectionInfo" class="hidden">
                <p class="status">Share this link with the viewer:</p>
                <input type="text" id="shareLink" readonly>
                <button id="copyButton">Copy Link</button>
            </div>
            
            <div class="status" id="sharerStatus"></div>
        </div>
        
        <div id="viewerSection" class="hidden">
            <div id="videoContainer">
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
            <div class="status" id="viewerStatus">Waiting for connection...</div>
        </div>
        
        <div class="info-section">
            <h3>How it works:</h3>
            <p>This app uses direct peer-to-peer WebRTC connections with no media servers involved. The connection information is exchanged via URL parameters.</p>
            <p><strong>Privacy first:</strong> Your screen sharing traffic goes directly between peers, not through any server.</p>
        </div>
    </div>

    <script>
        // Global variables
        let peerConnection;
        let localStream;
        const configuration = {
            iceServers: [
                { urls: "stun:stun.relay.metered.ca:80" },
                { urls: "stun:stun.l.google.com:19302" }
            ]
        };
        
        // DOM elements
        const shareButton = document.getElementById('shareButton');
        const stopButton = document.getElementById('stopButton');
        const copyButton = document.getElementById('copyButton');
        const shareLinkInput = document.getElementById('shareLink');
        const sharerStatus = document.getElementById('sharerStatus');
        const viewerStatus = document.getElementById('viewerStatus');
        const connectionInfo = document.getElementById('connectionInfo');
        const sharerSection = document.getElementById('sharerSection');
        const viewerSection = document.getElementById('viewerSection');
        const remoteVideo = document.getElementById('remoteVideo');
        
        // Check if we're a viewer (from URL params)
        const urlParams = new URLSearchParams(window.location.search);
        const offer = urlParams.get('offer');
        
        if (offer) {
            // We're the viewer
            sharerSection.classList.add('hidden');
            viewerSection.classList.remove('hidden');
            
            // Start as viewer
            startAsViewer(offer);
        } else {
            // We're the potential sharer
            shareButton.addEventListener('click', startSharing);
            stopButton.addEventListener('click', stopSharing);
            copyButton.addEventListener('click', copyShareLink);
        }
        
        // Function to start as the screen sharer
        async function startSharing() {
            try {
                sharerStatus.textContent = 'Requesting screen access...';
                
                // Get screen with audio
                localStream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: true
                });
                
                sharerStatus.textContent = 'Screen access granted. Setting up connection...';
                
                // Create peer connection
                peerConnection = new RTCPeerConnection(configuration);
                
                // Add tracks to peer connection
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
                
                // Create offer
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                // Wait for ICE gathering to complete
                await waitForIceGatheringComplete(peerConnection);
                
                sharerStatus.textContent = 'Connection ready! Waiting for viewer...';
                
                // Create share link with the offer
                const offerString = btoa(JSON.stringify(peerConnection.localDescription));
                const shareUrl = `${window.location.href}?offer=${offerString}`;
                shareLinkInput.value = shareUrl;
                connectionInfo.classList.remove('hidden');
                
                // Enable stop button
                shareButton.disabled = true;
                stopButton.disabled = false;
                
                // Setup event handlers for the connection
                setupPeerConnectionHandlers(peerConnection);
                
                // Handle ICE candidate events
                peerConnection.onicecandidate = event => {
                    if (event.candidate) {
                        // In a full app, we would send this to the signaling server
                        console.log("New ICE candidate");
                    }
                };
                
                // Handle connection state changes
                peerConnection.onconnectionstatechange = event => {
                    sharerStatus.textContent = `Connection: ${peerConnection.connectionState}`;
                    if (peerConnection.connectionState === 'connected') {
                        sharerStatus.textContent = 'Connected to viewer!';
                    } else if (peerConnection.connectionState === 'disconnected' || 
                               peerConnection.connectionState === 'failed') {
                        sharerStatus.textContent = 'Viewer disconnected';
                    }
                };
                
            } catch (error) {
                sharerStatus.textContent = `Error: ${error.message}`;
                console.error(error);
                stopSharing();
            }
        }
        
        // Function to stop sharing
        function stopSharing() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            
            sharerStatus.textContent = '';
            connectionInfo.classList.add('hidden');
            shareButton.disabled = false;
            stopButton.disabled = true;
        }
        
        // Function to start as the viewer
        async function startAsViewer(offerString) {
            try {
                viewerStatus.textContent = 'Connecting to shared screen...';
                
                // Decode the offer from URL
                const offerData = JSON.parse(atob(offerString));
                
                // Create peer connection
                peerConnection = new RTCPeerConnection(configuration);
                
                // Setup event handlers for the connection
                setupPeerConnectionHandlers(peerConnection);
                
                // Set remote description from offer
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offerData));
                
                // Create answer
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                
                // In a full signaling solution, we would send this answer to the sharer
                console.log("Created answer");
                
                viewerStatus.textContent = 'Connecting...';
                
            } catch (error) {
                viewerStatus.textContent = `Error: ${error.message}`;
                console.error(error);
            }
        }
        
        // Function to setup common peer connection handlers
        function setupPeerConnectionHandlers(pc) {
            // Handle incoming streams
            pc.ontrack = event => {
                console.log("Received remote track");
                if (event.streams && event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    
                    if (viewerSection.classList.contains('hidden')) {
                        // We're the sharer, but we can see our own stream for testing
                    } else {
                        // We're the viewer
                        viewerStatus.textContent = 'Connected! Receiving screen share.';
                    }
                }
            };
            
            // Handle connection state changes
            pc.onconnectionstatechange = event => {
                console.log(`Connection state: ${pc.connectionState}`);
                if (pc.connectionState === 'connected') {
                    if (!viewerSection.classList.contains('hidden')) {
                        viewerStatus.textContent = 'Connected!';
                    }
                } else if (pc.connectionState === 'disconnected' ||
                           pc.connectionState === 'failed') {
                    if (!viewerSection.classList.contains('hidden')) {
                        viewerStatus.textContent = 'Disconnected from sharer';
                    }
                }
            };
        }
        
        // Function to copy share link
        function copyShareLink() {
            shareLinkInput.select();
            document.execCommand('copy');
            copyButton.textContent = 'Copied!';
            setTimeout(() => {
                copyButton.textContent = 'Copy Link';
            }, 2000);
        }
        
        // Helper function to wait for ICE gathering to complete
        function waitForIceGatheringComplete(pc) {
            return new Promise(resolve => {
                if (pc.iceGatheringState === 'complete') {
                    resolve();
                    return;
                }
                
                const checkState = () => {
                    if (pc.iceGatheringState === 'complete') {
                        pc.removeEventListener('icegatheringstatechange', checkState);
                        resolve();
                    }
                };
                
                pc.addEventListener('icegatheringstatechange', checkState);
                
                // Timeout after 5 seconds
                setTimeout(() => {
                    if (pc.iceGatheringState !== 'complete') {
                        pc.removeEventListener('icegatheringstatechange', checkState);
                        resolve();
                    }
                }, 5000);
            });
        }
    </script>
</body>
</html>
